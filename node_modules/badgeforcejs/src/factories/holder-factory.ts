import {Contract, ContractConfig} from '../contract';
import {HolderClient, Holder} from '../holder';

/**
 * Parses response from EVM for new contract creation
 * @param holderAddrRes      response from EVM
 * @return the address of the new contract
 */
export const parseHolderAddrRes = (holderAddrRes) => {
  return holderAddrRes.logs[0].args._location;
};

export class HolderFactory {
  /**
   * @param factory      instance from truffle-contract
   * @param holderClient instanstiated [[HolderClient]] object. This is used so that we can get a nice usable instance of the new contract right away
   */
    constructor(public factory: any, public holderClient: HolderClient) {}
    /**
     * Creates a new holder contract
     * @param  owner wallet address of the real world recipient
     * @return       an instanstiated [[Holder]] object
     */
    async newHolder(owner) {
        try {
            const newHolderAddr = await this.factory.createHolderContract(owner);
            const address = parseHolderAddrRes(newHolderAddr);
            return this.holderClient.getInstance(address);
        } catch (error) {
            throw new Error(error);
        }
    }
}

export class HolderFactoryClient extends Contract {
    /**
     * @param config       a configuration object [[ContractConfig]]
     * @param holderClient instanstiated [[HolderClient]] object. This is used so that we can get a nice usable instance of the new contract right away
     */
    constructor(config: ContractConfig, public holderClient: HolderClient) {
        super(config);
    }
    /**
     * @param  address address of the contract
     * @return         an instanstiated [[HolderFactory]] object
     */
    async getInstance(address: number) {
        try {
            const instance = await this.contractABI.at(address);
            return await new HolderFactory(instance, this.holderClient);
        } catch (error) {
            return error;
        }
	}
}
